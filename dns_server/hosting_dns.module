<?php
/**
 * @file DNS server node type is defined here.
 *
 * This is primarily a node module that implements the "front end" of the DNS
 * feature of the Aegir system.  Its role is to allow the admin to setup
 * DNS-related settings and defaults for provisioning new sites.  The
 * corresponding provision_dns.module in the provision project complements this
 * by implementing the drush-driven tasks that constitute the "backend" of the
 * system.
 **/

include_once(drupal_get_path('module', 'hosting_dns') . '/hosting_dns.admin.inc');
include_once(drupal_get_path('module', 'hosting_dns') . '/hosting_dns.api.inc');

function hosting_dns_hosting_service() {
  return array("dns_server" => t("DNS Server"));
}

function hosting_dns_help($section) {
  switch ($section) {
    case 'admin/help/provision#requirements':
      $output .= _hosting_requirements('config_dns_path');
      $output .= _hosting_requirements('visudo_dns');
      return $output;
      break;
    case 'dns_server' :
      return t("<strong>The DNS server which defines sites and their domains.</strong>
                Most sites will have a primary and secondary DNS server, at least one of which is usually 
		remote from the server on which the site actually resides.");
      break;
  }
}

function _hosting_config_dns_path_requirements() {
  $username = PROVISION_SCRIPT_USER;
  $group = PROVISION_WEB_GROUP;
  $path = PROVISION_CONFIG_PATH;
  $mkdir_cmd['@named_path'] = $path;
  $mkdir_cmd['@provision_link'] = url('admin/settings/provision');
  $mkdir_cmd['@mkdir_cmd'] = <<<EOF
    mkdir -p $path
    chown $username:$username $path
    chmod 0700 $path
EOF;

  $help['title'] = t('Write access to a directory to store configuration information');
  $help['summary'] = t('The Provision framework takes special care to make sure that the file permissions of the 
                        hosted sites are always as safe as can be, especially to make sure that the web server does 
			not have the ability to modify the code of the site, therefore this information is required 
			to assure that safety while keeping the sites accessible. 
			The recommended path is directly above your platform path, but it can be anywhere.');
  
  $help['configuration'][] = t('Based on your server configuration we have determined that your path should be <code>@named_path</code>,
  but you can change it in the <a href="@provision_link">provision_section</a>', $mkdir_cmd);
  $help['configuration'][] = t('Please enter the following commands : <pre>@mkdir_cmd</pre>', $mkdir_cmd);

  return $help;
}

function _hosting_visudo_dns_requirements() {
#  $username = PROVISION_SCRIPT_USER;
#  $cmd = trim(str_replace("sudo", '', PROVISION_RESTART_CMD));
#  $cmd = substr($cmd, 0, strpos($cmd, " "));
#  $visudo['@visudo_cmd'] = <<<EOF
#    sudo visudo
#EOF;
#  $visudo['@visudo_line'] = <<<EOF
#    $username = ALL=NOPASSWD: $cmd
#EOF;
}


## Not sure if this is necessary (stolen from db_server)
#function hosting_get_dns_server($hostname, $web_server = null) {
#  if (_hosting_valid_ip($hostname)) {
#    $ip = $hostname;
#    $hostname = gethostbyaddr($hostname);
#  } else {
#    $ip = gethostbyname($hostname);
#  }
#  $result = db_result(db_query("SELECT nid FROM {node} WHERE title in ('%s', '%s') and type='dns_server'", $ip, $hostname));
#  if ($result) {
#    return node_load($result);
#  }
#
#  return false;
#}

/**
 * Implementation of hook_node_info
 **/
function hosting_dns_node_info() {
  $types["dns_server"] =  array(
    "type" => 'dns_server', "name" => 'DNS server',
    "module" => 'hosting_dns',
    "has_title" => TRUE, "title_label" => t('Host name'), 
    "description" => hosting_dns_help("dns_server"),
    "has_body" => 0, "body_label" => '', "min_word_count" => 0);    
  return $types;
}

/**
 * Implementation of hook_perm
 **/
function hosting_dns_perm() {
  return array('create DNS server','view DNS server', 'edit DNS server', 'delete DNS server', 'administer DNS provisioning');
}

/**
 * Implementation of hook_access
 **/
function hosting_dns_access($op, $node) {
  global $user;

  switch($op) {
    case 'create':
      return user_access('create DNS server');
      break;
    case 'view':
      return user_access('view DNS server');
      break;
    case 'update':
      return user_access('edit DNS server');
      break;
    case 'delete':
      return user_access('delete DNS server');
      break;
    default:
      break;
  }
}

/** 
 * Implementation of hook_provision_args
 * Used to pass along configuration details to the backend provisioning tasks
 **/
function hosting_dns_provision_args($node, $task = '') {
  $values = array();
  if ($task == 'verify' || $task == 'install') {
    $values['load-provision-dns'] = TRUE;
    $values['load-provision-bind'] = TRUE;
    if ($node->type == 'site') {
      $platform = node_load($node->platform);
      $dns = node_load($platform->dns_server);
    } elseif ($node->type == 'platform') {
      $dns = node_load($node->dns_server);
    }

    $values['dns_id'] = $dns->nid;
    # $values['dns_zone'] = 
    $values['dns_ip'] = $dns->default_ip;
    $values['dns_expire'] = $dns->expire;
    $values['dns_retry'] = $dns->retry;
    $values['dns_minimum'] = $dns->minimum;
    $values['dns_ttl'] = $dns->ttl;
    $values['dns_xfer'] = $dns->xfer;
    $values['dns_email'] = $dns->email;
    $values['dns_ns1'] = $dns->ns1;
    $values['dns_ns2'] = $dns->ns2;

    # Engine specific stuff..
    $values['dns_zonedata'] = $dns->zonedata;
    $values['dns_named_conf'] = $dns->named_conf;
    $values['dns_named_checkconf'] = $dns->named_checkconf;
    $values['dns_named_checkzone'] = $dns->named_checkzone;
    $values['dns_named_rndc'] = $dns->named_rndc;
  }
  return $values;
}

/**
 * Small helper function to get DNS servers.
*/ 
function _hosting_get_dns_servers() {
  $return = array();
  $result = db_query("SELECT nid, title FROM {node} WHERE type='dns_server' AND status=1");
  while($server = db_fetch_object($result)) {
    $return[$server->nid] = $server->title;
  }
  return $return;
}


/**
 * Implementation of hook_form().
 */
function hosting_dns_form(&$node) {
  
  $form['title'] = array(
    '#type' => 'textfield',
    '#title' => t('Hostname'),
    '#description' => t('The address of the DNS server.'),
    '#size' => 30,
    '#default_value' => $node->title,
    '#maxlength' => 64,
    '#weight' => 0,
  );
  $form['engine'] = array(
    '#type' => 'select',
    '#title' => t('Type/Engine'),
    '#description' => t('The type of DNS server engine this is.'),
# These options should come from the available provision engines..
# the available engines should also be configurable, somehow.. 
    '#options' => array('bind' => t('BIND'), 'mydns' => t('MyDNS'), 'djbdns' => t('djbdns')),
    '#default_value' => $node->engine,
  );
  if ($node->engine == 'bind') {
    $form['bind_settings'] = array(
      '#type' => 'fieldset', 
      '#title' => t('BIND Config'),
      '#collapsible' => TRUE, '#collapsed' => TRUE,
    );
    $form['bind_settings']['zonedata'] = array(
      '#type' => 'textfield',
      '#title' => t('Zone Data Path'),
      '#description' => t('Full path to bind zonefiles. Must NOT be writable by Apache.'),
      '#default_value' => $node->zonedata ? $node->zonedata : PROVISION_CONFIG_PATH .'/named',
      '#size' => 40,
      '#maxlength' => 128,
    );
    $form['bind_settings']['named_conf'] = array(
      '#type' => 'textfield',
      '#title' => t('Local Bind Config Filename'),
      '#description' => t('Configuration file for Aegir-generated zones. Resides in zone data path and 
  must be included via named.conf'),
      '#default_value' => $node->named_conf ? $node->named_conf : 'named.conf.drupal',
      '#size' => 40,
      '#maxlength' => 128,
    );

    $form['bind_utilities'] = array(
      '#type' => 'fieldset', 
      '#title' => t('Bind Utilities'),
      '#collapsible' => TRUE, '#collapsed' => TRUE,
    );
    $form['bind_utilities']['named_checkconf'] = array(
      '#type' => 'textfield',
      '#title' => t('Full path to named-checkconf'),
      '#default_value' => $node->named_checkconf ? $node->named_checkconf : '/usr/sbin/named-checkconf',
      '#size' => 40,
      '#maxlength' => 128,
    );
    $form['bind_utilities']['named_checkzone'] = array(
      '#type' => 'textfield',
      '#title' => t('Full path to named-checkzone'),
      '#default_value' => $node->named_checkzone ? $node->named_checkzone : '/usr/sbin/named-checkzone',
      '#size' => 40,
      '#maxlength' => 128,
    );
    $form['bind_utilities']['rndc'] = array(
      '#type' => 'textfield',
      '#title' => t('Full path to rndc'),
      '#default_value' => $node->rndc ? $node->rndc : '/usr/sbin/rndc',
      '#size' => 40,
      '#maxlength' => 128,
    );
  }
  $form['dns_defaults'] = array(
    '#type' => 'fieldset', 
    '#title' => t('DNS Provisioning defaults'), 
    '#collapsible' => TRUE, 
    '#collapsed' => TRUE,
  );
  $form['dns_defaults']['default_ip'] = array(
    '#type' => 'textfield',
    '#title' => t('Default Server IP'),
    '#default_value' => $node->default_ip?$node->default_ip:'127.0.0.1',
    '#size' => 20,
    '#maxlength' => 15,
    '#description' => t('Use this IP as the default server for new zones.'),
  );
  $form['dns_defaults']['xfer'] = array(
    '#type' => 'textfield',
    '#title' => t('Zone Transfer Access List'),
    '#default_value' => $node->xfer,
    '#size' => 40,
    '#maxlength' => 255,
    '#description' => t('Comma-separated list of IP addresses allowed to transfer this zone via AXFR'),
  );
  $form['dns_defaults']['mbox'] = array(
    '#type' => 'textfield',
    '#title' => t('DNS Admin Email Address'),
    '#default_value' => $node->mbox,
    '#size' => 40,
    '#maxlength' => 128,
    '#description' => t('Ampersand will be converted to a period as per specification. This value will be entered into zonefiles.'),
  );
  $form['dns_defaults']['ns'] = array(
    '#type' => 'textarea',
    '#title' => t('Name Servers'),
    '#default_value' => $node->ns,
    '#size' => 40,
    '#maxlength' => 128,
    '#description' => t('Default DNS servers for zonefiles eg: ns1.example.com (1 per line)')
  );
  $form['dns_defaults']['refresh'] = array(
    '#type' => 'textfield',
    '#title' => t('Refresh'),
    '#default_value' => $node->refresh?$node->refresh:'7200',
    '#size' => 40,
    '#maxlength' => 128,
    '#description' => t('How often secondary servers should refresh this zone (default 2h)'),
  );
  $form['dns_defaults']['retry'] = array(
    '#type' => 'textfield',
    '#title' => t('Retry'),
    '#default_value' => $node->retry?$node->retry:'300',
    '#size' => 40, 
    '#maxlength' => 128,
    '#description' => t('How often secondary servers should retry in case of a problem (default 5m)'),
  );
  $form['dns_defaults']['expire'] = array(
    '#type' => 'textfield',
    '#title' => t('Expire'),
    '#default_value' => $node->expire?$node->expire:'604800',
    '#size' => 40,
    '#maxlength' => 128,
    '#description' => t('How long until the secondary servers expire the zone data (default 4w)'),
  );
  $form['dns_defaults']['minimum'] = array(
    '#type' => 'textfield',
    '#title' => t('Minimum TTL'),
    '#default_value' => $node->minimum?$node->minimum:'86400',
    '#size' => 40,
    '#maxlength' => 128,
    '#description' => t('Minimum caching time in case of failed lookups (default 1w)'),
  );
  $form['dns_defaults']['ttl'] = array(
    '#type' => 'textfield',
    '#title' => t('Time To Live'),
    '#default_value' => $node->ttl?$node->ttl:'86400',
    '#size' => 40,
    '#maxlength' => 128,
    '#description' => t('Default TTL for zone resource records without their own TTL value (default 1w)'),
  );

  return $form;
}

/**
 * Implementation of hook_validate().
 */
function hosting_dns_validate($node, &$form) {

  # TODO: validate all the various DNS fields!

  # and also the settings and utilities!

  if ($node->engine != 'bind') {
    form_set_error('engine', 'Only the BIND engine is supported at this time.');
  }
}

/**
 * Implementation of hook_insert().
 */
function hosting_dns_insert($node) {
   db_query("INSERT INTO {hosting_dns_server} (vid, nid, engine, default_ip, ns, mbox, refresh, retry, expire, minimum, ttl, xfer) 
      VALUES (%d, %d, '%s', '%s', '%s', '%s', '%s', '%s', '%s', '%s', '%s', '%s')", 
      $node->vid, $node->nid, $node->engine, $node->default_ip, $node->ns, $node->mbox, $node->refresh, $node->retry, $node->expire, $node->minimum, $node->ttl, $node->xfer);

   if ($node->engine == 'bind') {
     # prepare the data and serialize as array
     # zonedata and named_conf
     # named_checkconf, named_checkzone, and rndc
     $data = array(
       'zonedata' => $node->zonedata,
       'named_conf' => $node->named_conf,
       'named_checkconf' => $node->named_checkconf,
       'named_checkzone' => $node->named_checkzone,
       'rndc' => $node->rndc,
     );
     db_query("INSERT INTO {hosting_dns_server_config} (vid,nid,engine,data) VALUES (%d, %d, '%s', '%s')",
	       $node->vid, $node->nid, $node->engine, serialize($data));
   } # other engines will use this differently
}

/**
 * Implementation of hook_update().
 *
 * As an existing node is being updated in the database, we need to do our own
 * database updates.
 */
function hosting_dns_update($node) {
  if ($node->revision) {
    hosting_dns_insert($node);
  } else { 
    db_query("UPDATE {hosting_dns_server} SET engine = '%s', default_ip = '%s', ns = '%s', mbox = '%s', refresh = '%s', retry = '%s', expire = '%s', minimum = '%s', ttl = '%s', xfer = '%s' WHERE vid = %d", $node->engine, $node->default_ip, $node->ns, $node->mbox, $node->refresh, $node->retry, $node->expire, $node->minimum, $node->ttl, $node->xfer, $node->vid);

    if ($node->engine == 'bind') {
     $data = array(
       'zonedata' => $node->zonedata,
       'named_conf' => $node->named_conf,
       'named_checkconf' => $node->named_checkconf,
       'named_checkzone' => $node->named_checkzone,
       'rndc' => $node->rndc,
     );
     db_query("UPDATE {hosting_dns_server_config} SET engine = '%s', data = '%s' WHERE vid = %d", $node->engine, serialize($data), $node->vid);
    }
  }
}

function hosting_nodeapi_dns_server_delete_revision(&$node) {
  db_query('DELETE FROM {hosting_dns_server} WHERE vid = %d', $node->vid);
  db_query('DELETE FROM {hosting_dns_server_config} WHERE vid = %d', $node->vid);
}

/**
 * Implementation of hook_delete().
 */
function hosting_dns_delete($node) {
  db_query('DELETE FROM {hosting_dns_server} WHERE nid = %d', $node->nid);
  db_query('DELETE FROM {hosting_dns_server_config} WHERE nid = %d', $node->nid);
}

/**
 * Implementation of hook_load().
 */
function hosting_dns_load($node) {
  $additions = db_fetch_object(db_query('SELECT engine, default_ip, ns, mbox, refresh, retry, expire, minimum, ttl, xfer FROM {hosting_dns_server} WHERE vid = %d', $node->vid));

  $config_obj = db_fetch_object(db_query('SELECT vid,engine,data FROM {hosting_dns_server_config} WHERE vid = %d AND engine="%s"', $node->vid, $additions->engine));

  if ($additions->engine == 'bind') {
    $bind_settings = unserialize($config_obj->data);

    $additions->zonedata = $bind_settings['zonedata'];
    $additions->named_conf = $bind_settings['named_conf'];
    $additions->named_checkconf = $bind_settings['named_checkconf'];
    $additions->named_checkzone = $bind_settings['named_checkzone'];
    $additions->rndc = $bind_settings['rndc'];
  }
  return $additions;
}

/**
 * Implementation of hook_view().
 */
function hosting_dns_view($node, $teaser = FALSE, $page = FALSE) {
  $node = node_prepare($node, $teaser);

  $node->content['engine'] = array(
    '#type' => 'fieldset',
    '#title' => t('DNS engine: ' . $node->engine),
    '#collapsible' => TRUE,
    '#collapsed' => TRUE,
    '#weight' => -1,
  );
  if ($node->engine == 'bind' && user_access('administer DNS provisioning')) {
    $node->content['engine']['zonedata'] = array(
      '#type' => 'item',
      '#title' => t('Zone Data directory'),
      '#value' => $node->zonedata,
      '#weight' => -1,
    );
    $node->content['engine']['named_conf'] = array(
      '#type' => 'item',
      '#title' => t('Named config file'),
      '#value' => $node->named_conf,
    );

    $node->content['engine']['named_checkconf'] = array(
      '#type' => 'item',
      '#title' => t('Named config utility'),
      '#value' => $node->named_checkconf,
    );
    $node->content['engine']['named_checkzone'] = array(
      '#type' => 'item',
      '#title' => t('Named zone utility'),
      '#value' => $node->named_checkzone,
    );
    $node->content['engine']['rndc'] = array(
      '#type' => 'item',
      '#title' => t('Named RNDC utility'),
      '#value' => $node->rndc,
    );
  }

  $node->content['defaults'] = array(
    '#type' => 'fieldset',
    '#title' => t('Defaults'),
    '#collapsible' => TRUE,
    '#collapsed' => $teaser?TRUE:FALSE,
  );
  $node->content['defaults']['default_ip'] = array(
    '#type' => 'item',
    '#title' => t('Default Server IP'),
    '#value' => $node->default_ip,
  );
  $node->content['defaults']['ns'] = array(
    '#type' => 'item',
    '#title' => t('Default NS Records'),
    '#value' => preg_replace("/\n/", '<br />', $node->ns),
  );
  $node->content['defaults']['mbox'] = array(
    '#type' => 'item',
    '#title' => t('DNS Admin Email'),
    '#value' => $node->mbox,
  );
  $node->content['defaults']['refresh'] = array(
    '#type' => 'item',
    '#title' => t('Refresh'),
    '#value' => $node->refresh,
  );
  $node->content['defaults']['retry'] = array(
    '#type' => 'item',
    '#title' => t('Retry'),
    '#value' => $node->retry,
  );
  $node->content['defaults']['expire'] = array(
    '#type' => 'item',
    '#title' => t('Expire'),
    '#value' => $node->expire,
  );
  $node->content['defaults']['minimum'] = array(
    '#type' => 'item',
    '#title' => t('Minimum TTL'),
    '#value' => $node->minimum
  );
  $node->content['defaults']['ttl'] = array(
    '#type' => 'item',
    '#title' => t('TTL'),
    '#value' => $node->ttl,
  );
  $node->content['defaults']['xfer'] = array(
    '#type' => 'item',
    '#title' => t('Zone Transfer Access List'),
    '#value' => $node->xfer,
  );
  
# This should show a table of all sites that use this DNS server to host their domain?
# Needs entries in hosting_site table to work properly..
#  $node->content['sites_view'] = array(
#    '#type' => 'item',
#    '#title' => t("Sites"),
#    '#value' => hosting_site_list("dns_server", $node->nid), 
#    '#weight' => 10,
#  );
  
  return $node;
}

/**
 * Implementation of hook_hosting_summary.
 *
 * Provides a list of existing DNS servers for the hosting summary block.
 **/
function hosting_dns_hosting_summary() {
  $summary = array();
  $dns_servers = _hosting_get_dns_servers();
  $summary['dns_servers'] = theme('item_list', array_map('_hosting_node_link', array_keys($dns_servers)), t('DNS Servers'));
  return $summary;
}

/**
 * Implementation of hook_form_alter.
 *
 * Add a radio button field to select a DNS server on platforms. This field is
 * hidden if only one DNS server is available.
 * Also adds a select field to site nodes to determine the primary DNS server for the site.
 **/
function hosting_dns_form_alter($form_id, &$form) {
  
  if ($form_id == 'platform_node_form') {
    $dns_servers = _hosting_get_dns_servers();
    if (sizeof($dns_servers) > 1) {
      $form['dns_server'] = array(
	'#type' => 'radios',
	'#title' => t('DNS Server'),
	'#description' => t('The DNS server the site domains will be hosted on.'),
	'#options' => $dns_servers,
	'#default_value' => ($form['#node']->dns_server) ? $form['#node']->dns_server : HOSTING_DEFAULT_DNS_SERVER,
      );
    } else {
      $dns_nid = key($dns_servers);
      $form['dns_server'] = array('#type' => 'hidden', '#value' => $dns_nid);
      $form['dns_server_show'] = array(
        '#type' => 'item', 
        '#title' => t('DNS Server'),
        '#value' => $dns_servers[$dns_nid],
        '#description' => t('The default DNS server has been chosen for this platform, as there are no others to choose from.'),
      );
    }
  }
  if ($form_id == 'site_node_form') {
    $form['dns_server'] = array(
      '#type' => 'select',
      '#title' => t('DNS Server'),
      '#description' => t('Select a primary DNS server on which to provision this site\'s domain.'),
      '#options' => _hosting_get_dns_servers(),
      '#default_value' => $form['#node']->dns_server,
    );
  }
}

/**
 * Helper function for hook_nodeapi to insert platform -> dns_server mapping
 **/
function hosting_dns_platform_insert($node) {
  db_query("INSERT INTO {hosting_dns_platform} (vid, nid, dns_server) VALUES (%d, %d, %d)", $node->vid, $node->nid, $node->dns_server);
}

/**
 * Helper function for hook_nodeapi to load dns_servers for a platform
 * 
 * @param $node
 *   The platform node for which to get a DNS server.
 **/
function hosting_get_dns_server($node) {
  $dns_nid = db_result(db_query("SELECT dns_server FROM {hosting_dns_platform} WHERE nid=%d AND vid=%d", $node->nid, $node->vid));
  if ($dns_nid) {
    return $dns_nid;
  } else {
    return HOSTING_DEFAULT_DNS_SERVER;
  }
}


/**
 * Implementation of hook_nodeapi
 * 
 * Validate site URLs to ensure they fall within a valid TLD.
 * Also manage inserts, updates, and deletions of DNS servers when platform nodes change.
 **/
function hosting_dns_nodeapi(&$node, $op, $a3 = NULL, $a4 = NULL) {
  if ($node->type == 'site') {
    switch($op) {
      case 'insert':
        # create the zone, if necessary
        # add the RR
        # create the node association:
        #db_query("INSERT INTO {hosting_dns_server_zone} (vid,nid,zid,rid)" 
        hosting_dns_insert($node);
        break;
      case 'update':
        #
        hosting_dns_update($node);
        break;
      case 'delete':
        # remove the RR (which triggers removal of the zone, if empty)
        hosting_dns_delete($node);
        break;
      case 'delete revision':
        hosting_dns_delete_revision($node);
        break;
      case 'validate': # This one gets $a3 as $form
        # check the form of the site name for url-ness
        break;
      case 'load':
        # add the $zone object and $rid to the $node
#       $additions['dns_server'] = hosting_dns_get_
        break;
      case 'view': # This one gets $a3 = $teaser, and $a4 = $path
        if (user_access('administer DNS provisioning')) {
          # show the zone/rr details?
        }
        break;
    }
  }
#  if ($op == 'validate' && $node->type == 'site') {
#    $tlds = split("\n", variable_get('provision_dns_tlds', ''));
#    $matched_tld = FALSE;
#    foreach ($tlds as $tld) {
#      $tld = trim($tld);
#      $pat = "/".$tld."$/";
#      if (preg_match($pat, $node->title)) {
#        $matched_tld = TRUE;
#        break;
#      }
#    }
#    if (!$matched_tld) {
#      form_set_error('title', t("The URL you have provided is not within a valid Top-Level Domain to be provisioned."));
#    }
#  }
  if ($node->type == 'platform') {
    switch ($op) {
      case 'insert':
        hosting_dns_platform_insert($node);
        break;
      case 'update':
        $exists = db_result(db_query("SELECT dns_server FROM {hosting_dns_platform} WHERE nid = %d and vid = %d", $node->nid, $node->vid));
        if ($node->revision || !$exists) {
          hosting_dns_platform_insert($node);
        } else {
          db_query("UPDATE {hosting_dns_platform} SET dns_server = %d WHERE nid = %d AND vid = %d", $node->dns_server, $node->nid, $node->vid);
        }
        break;
      case 'delete':
        db_query("DELETE FROM {hosting_dns_platform} WHERE nid=%d", $node->nid);
        break;
      case 'delete revision':
        db_query("DELETE FROM {hosting_dns_platform} WHERE nid=%d AND vid=%d", $node->nid, $node->vid);
        break;
      case 'validate':
        break;
      case 'load':
        return array('dns_server' => hosting_get_dns_server($node));
        break;
      case 'view':
        $dns_server = hosting_get_dns_server($node);
        
	$node->content['info']['dns_server'] = array(
	  '#type' => 'item',
	  '#title' => t('DNS server'),
	  '#value' => _hosting_node_link($dns_server),
	  '#weight' => -6
	);
        break;
    }
  }
}

// Utility functions

/**
 * Helper function to get the zid for a given zone
 *
 * @param $origin
 *   The name (or origin) of the zone/domain **/
function _hosting_dns_get_zid($origin) {
  return db_result(db_query("SELECT zid FROM {hosting_dns_soa} WHERE origin LIKE '%%%s%%'", $origin));
}   

/**
 * Need to modify this to use an admin-generated list of TLDs, and return the * domain as the TLD plus one other component
 * Examples:
 *  domain.tld
 *  www.domain.tld
 *  sub.domain.tld
 *  www.sub.domain.tld
 *  sub.multi.domain.tld (domain has multiple parts before TLD, but after host?)
 **/
function _hosting_dns_split_url($url) {
  $tlds = split("\n", variable_get('hosting_dns_tlds', ''));
  $first_dot = strpos($url, '.');

  # Strip off the first part
  $host = substr($url, 0, $first_dot);
  $zone = substr($url, $first_dot);
  # If the remaining hostname is a TLD  
  if (in_array($zone, $tlds)) {
    # Add the first part back, and that's the zone (the host is @)    $zone = $host . $zone;
    $host = '@';
  } else {
    # that's the zone (and the host is the first part)
    $zone = substr($zone, 1); # strip the leading .
  }

  return array('host' => $host, 'zone' => $zone);
}
