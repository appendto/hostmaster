<?php
/**
 * @file Hosting module
 *
 * Contains just about all the interface magic of hostmaster.
 */
 

/**
 * Not split for performance reasons. Just to keep code together.
 */

include_once('hosting_help.inc');
include_once('hosting_views.inc');
include_once('hosting.wizard.inc');
include_once('hosting.queues.inc');

/**
 * Implementation of hook_menu()
 */
function hosting_menu($may_cache = true) {
  $items = array();
  hosting_wizard_menu($may_cache, $items);
  if ($may_cache) {
    $items[] = array(
      'path' => 'admin/settings/queues',
      'title' => t('Hosting queues'),
      'description' => t('Configure the frequency that cron, backup and task events are process'),
      'callback' => 'drupal_get_form',
      'callback arguments' => array('hosting_queues_configure'),
      'type' => MENU_NORMAL_ITEM,
      'access' => TRUE
    );
/*
    // Kludge : Replace node/add page to hide functionality.
    $items[] = array('path' => 'node/add',
      'title' => t('Create content'),
      'callback' => '_hosting_node_add',
      'access' => user_access('access content'),
      'type' => MENU_ITEM_GROUPING,
      'weight' => 1);
    // Disable unsupported features.
    $features = module_invoke_all('hosting_features');
    $types = node_get_types();
    foreach ($types as $type) {
      if (isset($features[$type->type])) {
        $type_url_str = str_replace('_', '-', $type->type);
        $items[] = array(
          'path' => 'node/add/'. $type_url_str,
          'title' => drupal_ucfirst($type->name),
          'access' => node_access('create', $type->type) && (hosting_feature($type->type) !== HOSTING_FEATURE_DISABLED),
        ); 
      }
    }
 */

  }
  return $items;
}


/**
 * Implementation of hook_nodeapi
 *
 * This function redirects to hosting_nodeapi_$nodetype_$op calls, to save ourselves
 * from an incessant amount of intricately nested code, and allow easier extension / maintenance.
 */
function hosting_nodeapi(&$node, $op, $teaser) {
  $func = "hosting_nodeapi_" . $node->type . "_" . str_replace(" ", "_", $op);
  if (function_exists($func)) {
    $func($node, $op, $teaser);
  }
}

function hosting_drush_command() {
  $items['hosting dispatch'] = array(
    'callback' => 'hosting_dispatch',
    'description' => 'Centralized command for dispatching the various queue processors (hosting, cron, backup etc.)'
  );

  $items['hosting setup'] = array(
    'callback' => 'hosting_setup',
    'description' => t('Set up initial configuration settings such as the cron entry for the queue dispatcher and more.'),
  );

  $queues = hosting_get_queues();
  foreach ($queues as $queue => $info) {
    $dispatch = t("Dispatched: @items items every @frequency minutes", array('@items' => $info['items'], '@frequency' => round($info['frequency'] / 60)));
    $items['hosting ' . $queue] = array(
      'callback' => 'hosting_run_queue', 
      'description' => $info['description'] . " " . $dispatch
    );
  }
  
  return $items;
}

define('HOSTING_FEATURE_DISABLED', 0);
define('HOSTING_FEATURE_ENABLED', 1);
define('HOSTING_FEATURE_REQUIRED', 2);

function hosting_feature($feature) {
  static $features = array();

  if (!sizeof($features)) {
    $features = module_invoke_all("hosting_features");
  }

  return variable_get('hosting_feature_' . $feature, $features[$feature]['status']);
}

/**
 * Implementation of hook_form_alter
 */
function hosting_form_alter($form_id, &$form) {
  // Replace configuration form submit handler
  if ($form_id == 'provision_configure') {
    $form['#submit'] = array('hosting_configure_provision' => array());
  }

}

/**
 * Implementation of hook_perm
 */
function hosting_perm() {
  return array('access hosting wizard', 'administer hosting queues');
}

/**
 * Implementation of hook_init
 */
function hosting_init() {
  // Definitions for the default platforms, clients etc.
  // Done to avoid using 'magic numbers'
  define('HOSTING_DEFAULT_CLIENT', variable_get('hosting_default_client', 1));
  define('HOSTING_DEFAULT_DB_SERVER', variable_get('hosting_default_db_server', 2));
  define('HOSTING_DEFAULT_WEB_SERVER', variable_get('hosting_default_web_server', 3));
  define('HOSTING_DEFAULT_PLATFORM', variable_get('hosting_default_platform', 6)); 

  define('HOSTING_OWN_DB_SERVER', variable_get('hosting_own_db_server', 2));
  define('HOSTING_OWN_WEB_SERVER', variable_get('hosting_own_web_server', 3));
  define('HOSTING_OWN_PLATFORM', variable_get('hosting_own_platform', 6)); 
}

/**
 * Replacement submit handler for the admin/settings/provision page
 *
 * This submit handler saves the settings to the current provision environments'
 * individual nodes. These nodes intelligently save the settings provision uses
 * in it's environment.
 */

function hosting_configure_provision($form_id, &$values) {
  $platform = node_load(HOSTING_OWN_PLATFORM);
  $platform->revision = true;
  $platform->publish_path = $_SERVER['DOCUMENT_ROOT'];
  node_save($platform);

  $db_server = node_load(HOSTING_OWN_DB_SERVER);
  $db_server->revision = true;
  $db_server->title = $values['db_server']['db_host'];
  $db_server->db_user = $values['db_server']['db_user'];
  $db_server->db_type = $values['db_server']['db_type'];
  if ($values['db_server']['db_passwd']) {
    $db_server->db_passwd = $values['db_server']['db_passwd'];
  }
  node_save($db_server);
  
  $web_server = node_load($platform->web_server);
  $web_server->revision = true;
  $web_server->config_path = $values['web_server']['config_path'];
  $web_server->backup_path = $values['web_server']['backup_path'];
  $web_server->script_user = $values['web_server']['script_user'];
  $web_server->restart_cmd = $values['web_server']['restart_cmd'];
  $web_server->web_group = $values['web_server']['web_group'];
  node_save($web_server);
}

/**
 * Maps the properties of a node object to an associative array, based on node type, incrementally.
 *
 * The back end provisioning system accepts communication via a set of pre-defined arguments.
 * This function will generate whatever information can be extracted from a specific task, 
 * regardless what node type it is related to, and use this for generating the command to be executed.
 *
 * This functionality is similar in scope to the token module, but the token module contains much additional
 * complexity that was not necessary for us, and provided a lot of information that we did not need.
 *
 * @param node
 *    A node id, or node of any type defined by the hosting system.
 *    Will call hook_hosting_map_values_$node->type to provide actual mappings.
 * @return
 *    An associative array of terms to be used on the command line, or in templates.
 */
function hosting_map_values($node) {
  if (is_numeric($node)) {
    $node = node_load($node);
  }
  $values = array();
  
  $func = 'hosting_map_values_' . $node->type;
  if (function_exists($func)) {
    $values = $func($node);      
  }

  return $values;
}

function _hosting_node_link($nid) {
  $node = node_load($nid);
  if ($node->nid) {
    return l($node->title, "node/" . $node->nid);
  }
}

/**
 * Creates a new block.
 */
function _hosting_add_block($module, $delta, $theme, $status, $weight, $region, $visibility = 0, $pages = '', $custom = 0, $throttle = 0, $title = '') {
  db_query("INSERT INTO {blocks} (module, delta, theme, status, weight, region, visibility, pages, custom, throttle, title) 
     VALUES ('%s', '%s', '%s', %d, %d, '%s', %d, '%s', %d, %d, '%s')", 
     $module, $delta, $theme, $status, $weight, $region, $visibility, $pages, $custom, $throttle, $title);
  if ($module == 'block') {
    $box = db_fetch_object(db_query('SELECT * FROM {boxes} WHERE bid=%d', $delta));
    db_query("INSERT INTO {boxes} (bid, body, info, format) VALUES (%d, '%s', '%s', '%s')", $box->bid, $box->body, $box->info, $box->format);
  }
}

/**
 * Check if a hostname provided is an ip address
 */
function _hosting_valid_ip($hostname) {
  //TODO : provide IPv6 support
  $parts = explode('.', $hostname);
  if (sizeof($parts) != 4) {
    return false;
  }
  foreach ($parts as $part) {
    if (((int) $part < 0) || ((int) $part > 255)) {
      return false;
    }
  }
  return true;
}

function hosting_format_interval($ts) {
  if ($ts==mktime()) { 
    return t('Now');
  }
  if (!$ts) {
    //Treats EPOCH as never
    return t('Never');
  }

  return t("@interval ago", array("@interval" => format_interval(mktime() - $ts, 1)));
}

function hosting_setup() {
  variable_set('hosting_dispatch_enabled', FALSE);
  if ($exists = _provision_create_dir(PROVISION_CONFIG_PATH, t('Config path'), 0700)) {
    if ($exists = _provision_create_dir(PROVISION_DRUSHRC_PATH, t('Drush config path'), 0700)) {
      ## attempting to run the dispatch command, to make sure it runs without the queue being
      ## enabled.
      variable_set('hosting_dispatch_enabled', TRUE);
      exec(_hosting_dispatch_cmd(), $return, $code);
      variable_set('hosting_dispatch_enabled', FALSE);
      $return = join("\n", $return);
      $data = unserialize($return);
      if ($code == PROVISION_SUCCESS) {
        ## Run the dispatch command again to import the existing sites.
        variable_del('hosting_queue_dispatch_last_run');
        variable_set('hosting_dispatch_enabled', TRUE);
        exec(_hosting_dispatch_cmd(), $return, $code);
        provision_log("message", t("Dispatch command was run successfully"));
        _hosting_setup_cron();
      }
      else {
        provision_log("error", t("Dispatch command could not be run. Returned: \n@return", array('@return' => $return))); 
        provision_set_error(PROVISION_FRAMEWORK_ERROR);
      }
    }
  }
  $logs = provision_get_log();
  foreach ($logs as $log) {
    print "$log[message]\n";
  }

  if (provision_get_error()) {
    print "\nThe command did not complete successfully, please fix the issues and re-run this script.";
  }
}

function _hosting_setup_cron() {
  $newcron = array();
  $existing = FALSE;
  exec('crontab -l 2> /dev/null', $oldcron);
  if (sizeof($oldcron)) {
    foreach ($oldcron as $line => $entry) {
      if (preg_match('/hosting dispatch/', $entry)) {
        provision_log("Notice", t("Existing hosting dispatch cron entry was found. Not replacing"));
        $existing = TRUE;
        break;
      }
    }
  }
  else {
    provision_log("message", t("No existing crontab was found"));
  }

  if (!$existing) {
    if (sizeof($oldcron)) {
      $newcron = $oldcron;
      variable_set('hosting_cron_backup', $oldcron);
    }
    $newcron[] = hosting_queues_cron_cmd();
    $tmpnam = tempnam('hostmaster', 'hm.cron');
    $fp = fopen($tmpnam, "w");
    foreach ($newcron as $line) {
      fwrite($fp, $line . "\n");
    }
    fclose($fp);
    system(sprintf('crontab %s', escapeshellarg($tmpnam)));
    unlink($tmpnam);
    provision_log("Notice", t("Installed hosting dispatch cron entry to run every minute"));
  }
}

/**
 * Replacement node/add page.
 *
 * Major kludge to remove the hidden node types from node/add page
 *
 * Copied from node.module
 */
function _hosting_node_add() {
  global $user;

  $types = node_get_types();
  $type = isset($type) ? str_replace('-', '_', $type) : NULL;
  // If a node type has been specified, validate its existence.
  if (isset($types[$type]) && node_access('create', $type) && (hosting_feature($type) !== HOSTING_FEATURE_DISABLED)) {
    // Initialize settings:
    $node = array('uid' => $user->uid, 'name' => $user->name, 'type' => $type);

    drupal_set_title(t('Submit @name', array('@name' => $types[$type]->name)));
    $output = drupal_get_form($type .'_node_form', $node);
  }
  else {
    // If no (valid) node type has been provided, display a node type overview.
    foreach ($types as $type) {
      if (function_exists($type->module .'_form') && node_access('create', $type->type) && (hosting_feature($type->type) !== HOSTING_FEATURE_DISABLED)) {
        $type_url_str = str_replace('_', '-', $type->type);
        $title = t('Add a new @s.', array('@s' => $type->name));
        $out = '<dt>'. l(drupal_ucfirst($type->name), "node/add/$type_url_str", array('title' => $title)) .'</dt>';
        $out .= '<dd>'. filter_xss_admin($type->description) .'</dd>';
        $item[$type->name] = $out;
      }
    }

    if (isset($item)) {
      uksort($item, 'strnatcasecmp');
      $output = t('Choose the appropriate item from the list:') .'<dl>'. implode('', $item) .'</dl>';
    }
    else {
      $output = t('No content types available.');
    }
  }

  return $output;
}



