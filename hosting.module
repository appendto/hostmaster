<?php
/**
 * @file Hosting module
 *
 * Contains just about all the interface magic of hostmaster.
 */
 

/**
 * Not split for performance reasons. Just to keep code together.
 */

include_once('hosting_help.inc');
include_once('hosting_views.inc');
include_once('hosting.wizard.inc');
include_once('hosting.queues.inc');

/**
 * Implementation of hook_menu()
 */
function hosting_menu($may_cache = true) {
  $items = array();
  hosting_wizard_menu($may_cache, $items);
  if ($may_cache) {
    $items[] = array(
      'path' => 'admin/settings/queues',
      'title' => t('Hosting queues'),
      'description' => t('Configure the frequency that cron, backup and task events are process'),
      'callback' => 'drupal_get_form',
      'callback arguments' => array('hosting_queues_configure'),
      'type' => MENU_NORMAL_ITEM,
      'access' => TRUE
    );
  }
  return $items;
}

function hosting_access($op, $node) {
  global $user;

  if ($op == 'create') {
    return user_access('create hosting nodes');
  }

  if ($op == 'view') {
    return user_access('access hosting nodes');
  }

  if ($op == 'update' || $op == 'delete') {
    if (user_access('edit own hosting nodes') && ($user->uid == $node->uid)) {
      return TRUE;
    }
  }
}


/**
 * Implementation of hook_nodeapi
 *
 * This function redirects to hosting_nodeapi_$nodetype_$op calls, to save ourselves
 * from an incessant amount of intricately nested code, and allow easier extension / maintenance.
 */
function hosting_nodeapi(&$node, $op, $teaser) {
  $func = "hosting_nodeapi_" . $node->type . "_" . str_replace(" ", "_", $op);
  if (function_exists($func)) {
    $func($node, $op, $teaser);
  }
}

function hosting_drush_command() {
  $items['hosting dispatch'] = array(
    'callback' => 'hosting_dispatch',
    'description' => 'Centralized command for dispatching the various queue processors (hosting, cron, backup etc.)'
  );

  $items['hosting setup'] = array(
    'callback' => 'hosting_setup',
    'description' => t('Set up initial configuration settings such as the cron entry for the queue dispatcher and more.'),
  );

  $queues = hosting_get_queues();
  foreach ($queues as $queue => $info) {
    $dispatch = t("Dispatched: @items items every @frequency minutes", array('@items' => $info['items'], '@frequency' => round($info['frequency'] / 60)));
    $items['hosting ' . $queue] = array(
      'callback' => 'hosting_run_queue', 
      'description' => $info['description'] . " " . $dispatch
    );
  }
  
  return $items;
}


/**
 * Implementation of hook_form_alter
 */
function hosting_form_alter($form_id, &$form) {
  // Replace configuration form submit handler
  if ($form_id == 'provision_configure') {
    $form['#submit'] = array('hosting_configure_provision' => array());
  }

}

/**
 * Implementation of hook_perm
 */
function hosting_perm() {
  return array('access hosting wizard', 'create hosting nodes', 'access hosting nodes', 'edit own hosting nodes');
}

/**
 * Implementation of hook_init
 */
function hosting_init() {
  // Definitions for the default platforms, clients etc.
  // Done to avoid using 'magic numbers'
  define('HOSTING_DEFAULT_CLIENT', variable_get('hosting_default_client', 1));
  define('HOSTING_DEFAULT_DB_SERVER', variable_get('hosting_default_db_server', 2));
  define('HOSTING_DEFAULT_WEB_SERVER', variable_get('hosting_default_web_server', 3));
  define('HOSTING_DEFAULT_PLATFORM', variable_get('hosting_default_platform', 6)); 

  define('HOSTING_OWN_DB_SERVER', variable_get('hosting_own_db_server', 2));
  define('HOSTING_OWN_WEB_SERVER', variable_get('hosting_own_web_server', 3));
  define('HOSTING_OWN_PLATFORM', variable_get('hosting_own_platform', 6)); 
}

/**
 * Replacement submit handler for the admin/settings/provision page
 *
 * This submit handler saves the settings to the current provision environments'
 * individual nodes. These nodes intelligently save the settings provision uses
 * in it's environment.
 */

function hosting_configure_provision($form_id, &$values) {
  $platform = node_load(HOSTING_OWN_PLATFORM);
  $platform->revision = true;
  $platform->publish_path = $_SERVER['DOCUMENT_ROOT'];
  node_save($platform);

  $db_server = node_load(HOSTING_OWN_DB_SERVER);
  $db_server->revision = true;
  $db_server->title = $values['db_server']['db_host'];
  $db_server->db_user = $values['db_server']['db_user'];
  $db_server->db_type = $values['db_server']['db_type'];
  if ($values['db_server']['db_passwd']) {
    $db_server->db_passwd = $values['db_server']['db_passwd'];
  }
  node_save($db_server);
  
  $web_server = node_load($platform->web_server);
  $web_server->revision = true;
  $web_server->config_path = $values['web_server']['config_path'];
  $web_server->backup_path = $values['web_server']['backup_path'];
  $web_server->script_user = $values['web_server']['script_user'];
  $web_server->restart_cmd = $values['web_server']['restart_cmd'];
  $web_server->web_group = $values['web_server']['web_group'];
  node_save($web_server);
}

/**
 * Maps the properties of a node object to an associative array, based on node type, incrementally.
 *
 * The back end provisioning system accepts communication via a set of pre-defined arguments.
 * This function will generate whatever information can be extracted from a specific task, 
 * regardless what node type it is related to, and use this for generating the command to be executed.
 *
 * This functionality is similar in scope to the token module, but the token module contains much additional
 * complexity that was not necessary for us, and provided a lot of information that we did not need.
 *
 * @param node
 *    A node id, or node of any type defined by the hosting system.
 *    Will call hook_hosting_map_values_$node->type to provide actual mappings.
 * @return
 *    An associative array of terms to be used on the command line, or in templates.
 */
function hosting_map_values($node) {
  if (is_numeric($node)) {
    $node = node_load($node);
  }
  $values = array();
  
  $func = 'hosting_map_values_' . $node->type;
  if (function_exists($func)) {
    $values = $func($node);      
  }

  return $values;
}

function _hosting_node_link($nid) {
  $node = node_load($nid);
  if ($node->nid) {
    return l($node->title, "node/" . $node->nid);
  }
}

/**
 * Creates a new block.
 */
function _hosting_add_block($module, $delta, $theme, $status, $weight, $region, $visibility = 0, $pages = '', $custom = 0, $throttle = 0, $title = '') {
  db_query("INSERT INTO {blocks} (module, delta, theme, status, weight, region, visibility, pages, custom, throttle, title) 
     VALUES ('%s', '%s', '%s', %d, %d, '%s', %d, '%s', %d, %d, '%s')", 
     $module, $delta, $theme, $status, $weight, $region, $visibility, $pages, $custom, $throttle, $title);
  if ($module == 'block') {
    $box = db_fetch_object(db_query('SELECT * FROM {boxes} WHERE bid=%d', $delta));
    db_query("INSERT INTO {boxes} (bid, body, info, format) VALUES (%d, '%s', '%s', '%s')", $box->bid, $box->body, $box->info, $box->format);
  }
}

/**
 * Check if a hostname provided is an ip address
 */
function _hosting_valid_ip($hostname) {
  //TODO : provide IPv6 support
  $parts = explode('.', $hostname);
  if (sizeof($parts) != 4) {
    return false;
  }
  foreach ($parts as $part) {
    if (((int) $part < 0) || ((int) $part > 255)) {
      return false;
    }
  }
  return true;
}

function hosting_format_interval($ts) {
  if ($ts==mktime()) { 
    return t('Now');
  }
  if (!$ts) {
    //Treats EPOCH as never
    return t('Never');
  }

  return t("@interval ago", array("@interval" => format_interval(mktime() - $ts, 1)));
}

function hosting_setup() {
  variable_set('hosting_dispatch_enabled', FALSE);
  if ($exists = _provision_create_dir(PROVISION_CONFIG_PATH, t('Config path'), 0700)) {
    if ($exists = _provision_create_dir(PROVISION_DRUSHRC_PATH, t('Drush config path'), 0700)) {
      ## attempting to run the dispatch command, to make sure it runs without the queue being
      ## enabled.
      variable_set('hosting_dispatch_enabled', TRUE);
      exec(_hosting_dispatch_cmd(), $return, $code);
      variable_set('hosting_dispatch_enabled', FALSE);
      $return = join("\n", $return);
      $data = unserialize($return);
      if ($code == PROVISION_SUCCESS) {
        variable_set('hosting_dispatch_enabled', TRUE);
        provision_log("message", t("Dispatch command was run successfully"));
        _hosting_setup_cron();
      }
      else {
        provision_log("error", t("Dispatch command could not be run. Returned: \n@return", array('@return' => $return))); 
        provision_set_error(PROVISION_FRAMEWORK_ERROR);
      }
    }
  }
  $logs = provision_get_log();
  foreach ($logs as $log) {
    print "$log[message]\n";
  }

  if (provision_get_error()) {
    print "\nThe command did not complete successfully, please fix the issues and re-run this script.";
  }
}

function _hosting_setup_cron() {
  $newcron = array();
  $existing = FALSE;
  exec('crontab -l 2> /dev/null', $oldcron);
  if (sizeof($oldcron)) {
    foreach ($oldcron as $line => $entry) {
      if (preg_match('/hosting dispatch/', $entry)) {
        provision_log("Notice", t("Existing hosting dispatch cron entry was found. Not replacing"));
        $existing = TRUE;
        break;
      }
    }
  }
  else {
    provision_log("message", t("No existing crontab was found"));
  }

  if (!$existing) {
    if (sizeof($oldcron)) {
      $newcron = $oldcron;
      variable_set('hosting_cron_backup', $oldcron);
    }
    $newcron[] = hosting_queues_cron_cmd();
    $tmpnam = tempnam('hostmaster', 'hm.cron');
    $fp = fopen($tmpnam, "w");
    foreach ($newcron as $line) {
      fwrite($fp, $line . "\n");
    }
    fclose($fp);
    system(sprintf('crontab %s', escapeshellarg($tmpnam)));
    unlink($tmpnam);
    provision_log("Notice", t("Installed hosting dispatch cron entry to run every minute"));
  }
}
