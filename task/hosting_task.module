<?php
/**
 * @file Web server node type is defined here.
 */
include_once('hosting_task.views.inc');

/**
 * Implementation of hook_menu().
 */
function hosting_task_menu($may_cache) {
  $items = array();
  
  if (!$may_cache) {
    if ( arg(0) == 'node' && is_numeric(arg(1))) {
      $node = node_load(arg(1));
      foreach (hosting_available_tasks($node) as $type => $task) {
          $items[] = array(
            'path' => 'node/' . arg(1) . '/task_' . $type,
            'title' => $task['title'],
            'description' => $task['description'],
            'callback' => 'drupal_get_form',
            'callback arguments' => array('hosting_task_confirm_form', $node, $type),
            'access' => user_access('can schedule tasks'),
            'type' => MENU_LOCAL_TASK,
            'weight' => ($task['weight']) ? $task['weight'] : 0, 
          );
          
        }
     }
  }
  return $items;
}

function hosting_task_node_info() {
  #management
  $types["task"] =  array(
    "type" => 'task', "name" => 'Task',
    "module" => 'hosting_task',
    "has_title" => FALSE, "title_label" => '', 
 #   "description" => hosting_node_help("task"),
    "has_body" => 0, "body_label" => '', "min_word_count" => 0);

  return $types;
}

function hosting_task_access($op, $node) {
  return hosting_access($op, $node);
}

function hosting_task_perm() {
  return array('can schedule tasks');
}

function hosting_task_log($vid, $type, $message, $severity = 0, $timestamp = null ) {
 $timestamp = ($timestamp) ? $timestamp : mktime();
 if (DRUSH_VERBOSE) print "$message\n";
 db_query("INSERT INTO {hosting_task_log} (vid, type, message, severity, timestamp) VALUES (%d, '%s', '%s', %d, %d)", $vid, $type, $message, $severity, $timestamp);
}


function hosting_map_values_task($node) {
  $values['task_id'] = $node->nid;
  $values['task_type'] = $node->task_type;
  if (is_array($node->task_args)) {
    $values['task_args'] = $node->task_args;
  }
  $reference = node_load($node->rid);
  $values['task_reference_type'] = $reference->type;
  $values['task_reference'] = $reference->nid;
  
  $values = array_merge($values, hosting_map_values($reference));    

  $values['#export_task'] = array_merge( 
    array('task_id'), 
    $values['#export_' . $reference->type]);

  return $values;
}

/**
 * Helper function to generate new task node
 */
function hosting_add_task($nid, $type, $args = null) {
 global $user;

 $node = node_load($nid);
 $task = new stdClass();
 $task->type = 'task';
 $task->uid = $user->uid;
 $task->status = 1;
 #todo: make this pretty
 $task->title = t("!type !title", array('!type' => $type, '!title' => $node->title) );
 $task->task_type = $type;
 $task->task_status = PROVISION_QUEUED;
 $task->rid = $node->nid;

 #arguments, such as which backup to restore.
 if (is_array($args)) {
   $task->task_args = $args;
 }
 node_save($task);
}

/**
 * Implementation of hook_form().
 */
function hosting_task_confirm_form(&$node, $task) {
  $tasks = hosting_available_tasks($node);
  $form['help'] = array('#value' => $tasks[$task]['description']); 
  $form['nid'] = array('#type' => 'value', '#value' => $node->nid);
  $form['task'] = array('#type' => 'value', '#value' => $task); 
  $form['parameters'] = array('#tree' => TRUE);
  $func = 'hosting_task_' . $task . '_form';
  if (function_exists($func)) {
    $form['parameters'] += $func($node);
  }
  $question = t("Are you sure you want to @task @object", array('@task' => $task, '@object' => $node->title));
  return confirm_form($form, $question, 'node/' . $node->nid, '', $tasks[$task]['title']);
}

function hosting_task_restore_form($node) {
  $list = hosting_site_backup_list($node->nid);
  if (sizeof($list)) {
    $form['bid'] = array(
      '#type' => 'radios',
      '#title' => t('Backups'),
      '#options' => $list,
      '#required' => TRUE
    );
  }
  else {
    $form['no_backups'] = array(
      '#type' => 'item', 
      '#title' => t('Backups'), 
      '#value' => t('There are no valid backups available.')
    );
  }
  return $form;
}

function hosting_task_confirm_form_submit($form_id, $values) {
  hosting_add_task($values['nid'], $values['task'], $values['parameters']);
  return 'node/' . $values['nid'];
}

function hosting_task_set_title(&$node) {
  $ref = node_load($node->rid);
  $node->title = drupal_ucfirst($node->task_type) . ' ' . $ref->title;
  db_query("UPDATE {node} SET title='%s' WHERE nid=%d", $node->title, $node->nid);
  db_query("UPDATE {node_revisions} SET title='%s' WHERE vid=%d", $node->title, $node->vid);
}

/**
 * Determine whether there is an outstanding task of a specific type.
 *
 * This is used to ensure that there are not multiple tasks of the same type queued.
 */
function hosting_task_outstanding($nid, $type) {
  $return = db_result(db_query("
      SELECT q.nid FROM 
         {hosting_task_queue} q LEFT JOIN {hosting_task} a ON a.nid=q.nid 
      WHERE 
        a.rid = %d 
        AND q.status = 0 
        AND a.task_type = '%s' 
        LIMIT 1", $nid, $type));
  return $return;
}

/**
 * Return the amount of items still in the queue
 */
function hosting_task_count() {
  return db_result(db_query("SELECT COUNT(q.nid) FROM {hosting_task_queue} q 
    LEFT JOIN {hosting_task} a ON a.nid=q.nid WHERE q.status = 0"));
}

function hosting_available_tasks($node) {
  $options = array();
  if ($node->type == 'site') {
    if (hosting_task_outstanding($node->nid, 'delete') || ($node->site_status & HOSTING_SITE_DELETED)) {
      return $options;
    }
    if (hosting_task_outstanding($node->nid, 'enable') || ($node->site_status & HOSTING_SITE_ENABLED)) {
      $options['backup']['title'] = t('Backup');
      $options['backup']['description'] = t('Generate a backup of this site that can be restored to at any time');
      $options['backup']['weight'] = 7;

      $options['restore']['title'] = t('Restore');
      $options['restore']['description'] = t('Restore this site to a previous backup. A new backup will be created before this is attempted.');
      $options['restore']['weight'] = 7;

      $options['synch']['title'] = t('Regenerate');
      $options['synch']['description'] = t('Regenerate all configuration files on server.');
      $options['synch']['weight'] =  9;

      $options['disable']['title'] =  t('Disable');      
      $options['disable']['description'] =  t('Disabling this site will stop it from being accessible. It can be enabled again later.');      
      $options['disable']['weight'] =  4;      
    }
    else {
      $options['enable']['title'] = t('Enable');
      $options['enable']['description'] = t('Enabling this site will allow it to be accesible again. It may be disabled again if needed.');
      $options['enable']['weight'] =  4;      

      $options['delete']['title'] = t('Delete');
      $options['delete']['description'] = t('Deleting this site will completely remove it from the hosting system, but will keep the last backup available. This process can not be undone. Are you really sure you want to delete this site?');
      $options['delete']['weight'] = 10;
    }
  }
  elseif (($node->type == 'platform') & !hosting_task_outstanding($node->nid, 'verify')) {
    $options['verify']['title'] = t('Verify');
    $options['verify']['description'] = t('Verify that the platform is correctly installed and working.');
    $options['verify']['weight'] = 10;
  }
  return $options;
}


/**
 * Implementation of hook_insert().
 */
function hosting_task_insert($node) {
  db_query("INSERT INTO {hosting_task} (vid, nid, task_type, rid, executed, task_status) VALUES (%d, %d, '%s', %d, %d, %d)",
    $node->vid, $node->nid, $node->task_type, $node->rid, $node->executed, $node->task_status);

  if (is_array($node->task_args)) {
    foreach ($node->task_args as $key => $value) {
      db_query("INSERT INTO {hosting_task_arguments} (vid, nid, name, value) VALUES (%d, %d, '%s', '%s')",
           $node->vid, $node->nid, $key, $value);
    }
  }
  hosting_task_set_title($node); 
  if ($node->is_new) {
    db_query("INSERT INTO {hosting_task_queue} (nid, timestamp, status) VALUES (%d, %d, %d)", $node->nid, mktime(), PROVISION_QUEUED);
  }
}

/**
 * Implementation of hook_update().
 *
 * As an existing node is being updated in the database, we need to do our own
 * database updates.
 */
function hosting_task_update($node) {
  // if this is a new node or we're adding a new revision,
  if ($node->revision) {
    hosting_task_insert($node);
  }
  else {
    hosting_task_set_title($node);
    db_query("UPDATE {hosting_task} SET nid=%d, task_type = '%s', rid = %d, executed=%d, task_status=%d WHERE vid=%d",
      $node->nid, $node->task_type, $node->rid, $node->executed, $node->task_status, $node->vid);
    if (is_array($node->task_args)) {
      # Wipe out old arguments first, since arguments could theoretically be removed.
      db_query("DELETE FROM {hosting_task_arguments} WHERE vid=%d", $node->vid);
      foreach ($node->task_args as $key => $value) {
        db_query("INSERT INTO {hosting_task_arguments} (vid, nid, name, value) VALUES (%d, %d, '%s', '%s')",
             $node->vid, $node->nid, $key, $value);
      }
    }
      
  }
}

function hosting_nodeapi_task_delete_revision(&$node) {
  db_query('DELETE FROM {hosting_task} WHERE vid = %d', $node->vid);
  db_query('DELETE FROM {hosting_task_arguments} WHERE vid = %d', $node->vid);
}

/**
 * Implementation of hook_delete().
 */
function hosting_task_delete($node) {
  db_query('DELETE FROM {hosting_task} WHERE nid = %d', $node->nid);
  db_query('DELETE FROM {hosting_task_arguments} WHERE nid = %d', $node->nid);
}

/**
 * Implementation of hook_load().
 */
function hosting_task_load($node) {
  $additions = db_fetch_object(db_query('SELECT task_type, executed, task_status, rid FROM {hosting_task} WHERE vid = %d', $node->vid));
  $result = db_query("SELECT name, value FROM {hosting_task_arguments} WHERE vid=%d", $node->vid);
  if (db_num_rows($result)) {
    while ($arg = db_fetch_object($result)) {
      $additions->task_args[$arg->name] = $arg->value;
    }
  }
  return $additions;
}

/**
 * Implementation of hook_view().
 */
function hosting_task_view($node, $teaser = FALSE, $page = FALSE) {
  drupal_add_css(drupal_get_path('module', 'hosting') . '/hosting.css');
  drupal_add_js(drupal_get_path('module', 'hosting') . '/hosting.js');
  $node = node_prepare($node, $teaser);
  
  $ref = node_load($node->rid);

  drupal_set_breadcrumb(array( 
    l(t('Home'), NULL), 
    l($ref->title, 'node/' . $ref->nid)
  ));
  $node->content['#prefix'] = '<div class="hosting-task-fields">';
  $node->content['#suffix'] = '</div>';
  $node->content['reference'] = array(
    '#type' => 'item',
    '#title' => drupal_ucfirst($ref->type),
    '#value' => _hosting_node_link($node->rid),
  );
  
  if ($node->executed) {
    $node->content['executed'] = array(
      '#type' => 'item',
      '#title' => t('Executed'),
      '#value' => format_date($node->executed),
    );
  } else {
    $queues = hosting_get_queues();
    $queue = $queues['tasks'];
    $freq = $queue['frequency'];
    $last = $queue['last_run'];
    $now = time();
    # the first part is the regular case: the task was never run, compute the next time
    # the second part is the case where the task wasn't run in the last queue run even though it was scheduled, so we compute the next iteration
    $next = max($last + $freq, ( $now - ( ($now - $last) % $freq ) ) + $freq );
    if ($freq < 60*60*12) { # 12h
      # display only the time if we have short iterations
      $date = format_date($next, 'custom', 'H:i:sO');
    } else {
      $date = format_date($next, 'medium');
    }
    $items = $queue['items'];
    $node->content['notexecuted'] = array(
      '#type' => 'item',
      '#title' => t('This task has not been processed yet'),
      '#value' => t('It will be processed around %date, if the queue is not too crowded. The queue is currently ran every %freq, was last ran %last and processes %items items at a time. Server time is %time.', array('%freq' => format_interval($freq), '%date' => $date, '%last' => hosting_format_interval($last), '%items' => $items, '%time' => format_date($now, 'custom', 'H:i:sO'))),
    );
  }
  if ($node->task_status) {
    $node->content['status'] = array(
      '#type' => 'item',
      '#title' => t('Status'),
      '#value' => implode(", ", _hosting_parse_error_code($node->task_status)),
    );
  }
  
  if ($table = _hosting_task_log_table($node->vid)) { 
    $node->content['hosting_log'] = array(
      '#weight' => 1,
      '#type' => 'item',
      '#title' => t('Log'),
      '#value' => $table
    );
  }
    
  return $node;
}

/**
 * Display table containing the logged information for this task
 */ 
function _hosting_task_log_table($vid) {
  $result = db_query("SELECT * FROM {hosting_task_log} WHERE vid=%d", $vid);
  if (db_num_rows($result)) {
    $header = array("");
    while ($entry = db_fetch_object($result)) {
      if (strlen($entry->message) > 300) {
        $summary = "<span class='hosting-task-summary'>" . filter_xss(substr($entry->message, 0, 75), array()) . "... <a href='javascript:void(0)' class='hosting-summary-expand'>(" . t('Expand') . ')</a></span>';
        $message = $summary . "<span class='hosting-task-full'>" . nl2br($entry->message) . '</span>';
      }
      else {
        $message = $entry->message;
      } 
      $row =  array($message);
      $rows[] = array('data' => $row, 'class' => _hosting_task_log_class($entry->type));
    }

    return theme("table", $header, (array) $rows, array('id' => 'hosting-task-log'));
  }

  return false; 
}

/**
 * Map entry statuses to coincide.
 *
 * @todo make this irrelevant.
 */
function _hosting_task_log_class($type) {
  switch (strtolower($type)) {
    case "warning" :
    case "error" : 
      $type = strtolower($type);
      break;
    case "command" : 
    case "queue" :
    case "notice" : 
      $type = "info";
      break;
    default: 
      $type = 'success';
      break;
  }

  return 'hosting-' . $type;
}

/**
 * Retrieve the latest task related to the specified platform, of a specific type
 *
 * This is used for documenting issues with verification.
 */
function hosting_get_most_recent_task($rid, $type) {
  $nid = db_result(db_query("SELECT nid FROM hosting_task t WHERE task_type='%s' and t.rid=%d ORDER BY t.executed DESC limit 1", $type, $rid));
  if ($nid) {
    return node_load($nid);
  }
  return false;
}


/**
 * Turn bitmask integer error code into associative array
 */
function _hosting_parse_error_code($code) {
  global $provision_errors;
  switch ($code) {
    case PROVISION_QUEUED : 
      return array(PROVISION_QUEUED => $provision_errors[PROVISION_QUEUED]);
      break;
    case PROVISION_SUCCESS : 
      return array(PROVISION_SUCCESS => $provision_errors[PROVISION_SUCCESS]);
      break;
    default:
      foreach ($provision_errors as $error => $message) {
        if (!in_array($error, array(PROVISION_QUEUED, PROVISION_SUCCESS))) {
          if ($code & $error) {
            $return[$error] = $message;
          }        
        }
      }
      return $return;
      break;
  }
}

